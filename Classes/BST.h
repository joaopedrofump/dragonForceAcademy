#ifndef _BINARYTREE_H
#define _BINARY_TREE_H

#include <iostream>
#include <stack>
#include <queue>
using namespace std;

////////////////////////////////////////////////////////////////////////////////////////////////////
/// <summary>	An in binary tree iterator. </summary>
///
/// <remarks>	Luís, 20/11/2016. </remarks>
///
/// <typeparam name="T">	Generic type parameter. </typeparam>
////////////////////////////////////////////////////////////////////////////////////////////////////

template <class T>
class BTItrIn;

////////////////////////////////////////////////////////////////////////////////////////////////////
/// <summary>	A pre binary tree iterator. </summary>
///
/// <remarks>	Luís, 20/11/2016. </remarks>
///
/// <typeparam name="T">	Generic type parameter. </typeparam>
////////////////////////////////////////////////////////////////////////////////////////////////////

template <class T>
class BTItrPre;

////////////////////////////////////////////////////////////////////////////////////////////////////
/// <summary>	A post binary tree iterator. </summary>
///
/// <remarks>	Luís, 20/11/2016. </remarks>
///
/// <typeparam name="T">	Generic type parameter. </typeparam>
////////////////////////////////////////////////////////////////////////////////////////////////////

template <class T>
class BTItrPost;

////////////////////////////////////////////////////////////////////////////////////////////////////
/// <summary>	A level binary tree iterator. </summary>
///
/// <remarks>	Luís, 20/11/2016. </remarks>
///
/// <typeparam name="T">	Generic type parameter. </typeparam>
////////////////////////////////////////////////////////////////////////////////////////////////////

template <class T>
class BTItrLevel;

////////////////////////////////////////////////////////////////////////////////////////////////////
/// <summary>	A binary tree. </summary>
///
/// <remarks>	Luís, 20/11/2016. </remarks>
///
/// <typeparam name="T">	Generic type parameter. </typeparam>
////////////////////////////////////////////////////////////////////////////////////////////////////

template <class T>
class BinaryTree;

////////////////////////////////////////////////////////////////////////////////////////////////////
/// <summary>	An underflow. </summary>
///
/// <remarks>	Luís, 20/11/2016. </remarks>
////////////////////////////////////////////////////////////////////////////////////////////////////

class Underflow { };

////////////////////////////////////////////////////////////////////////////////////////////////////
/// <summary>	A binary tree node. </summary>
///
/// <remarks>	Luís, 20/11/2016. </remarks>
///
/// <typeparam name="T">	Generic type parameter. </typeparam>
////////////////////////////////////////////////////////////////////////////////////////////////////

template <class T>
class BTNode {
    T element;
    BTNode *left, *right;

    
    friend class BinaryTree<T>;

    

    friend class BTItrIn<T>;

    

    friend class BTItrPre<T>;

   

    friend class BTItrPost<T>;

    

    friend class BTItrLevel<T>;
public:

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	Constructor. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ///
    /// <param name="e">  	The T to process. </param>
    /// <param name="esq">	[in,out] (Optional) If non-null, the left node. </param>
    /// <param name="dir">	[in,out] (Optional) If non-null, the right node. </param>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    BTNode(const T &e, BTNode *esq = 0, BTNode *dir = 0)
    : element(e), left(esq), right(dir) { }
    //added from professor's code

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	Gets the element. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ///
    /// <returns>	The element. </returns>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    T getElement() const {return this->element;}

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	Gets left node. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ///
    /// <returns>	Null if it fails, else the left node. </returns>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    BTNode* getLeftNode() const {return this->left;};

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	Gets right node. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ///
    /// <returns>	Null if it fails, else the right node. </returns>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    BTNode* getRightNode() const {return this->right;};
};

////////////////////////////////////////////////////////////////////////////////////////////////////
/// <summary>	A binary tree. </summary>
///
/// <remarks>	Luís, 20/11/2016. </remarks>
///
/// <typeparam name="T">	Generic type parameter. </typeparam>
////////////////////////////////////////////////////////////////////////////////////////////////////

template <class T>
class BinaryTree {
public:

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	Default constructor. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    BinaryTree() { root = 0; }

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	Copy constructor. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ///
    /// <param name="t">	The BinaryTree to process. </param>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    BinaryTree(const BinaryTree &t);

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	Constructor. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ///
    /// <param name="parameter1">	The first parameter. </param>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    BinaryTree(const T&);

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	Constructor. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ///
    /// <param name="elem">	The element. </param>
    /// <param name="esq"> 	The left node. </param>
    /// <param name="dir"> 	The right node. </param>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    BinaryTree(const T&elem, const BinaryTree & esq, const BinaryTree & dir);

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	Destructor. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    ~BinaryTree() { makeEmpty(); }

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	Assignment operator. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ///
    /// <param name="rhs">	The right hand side. </param>
    ///
    /// <returns>	A shallow copy of this object. </returns>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    const BinaryTree &operator=(const BinaryTree & rhs);

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	Query if this object is empty. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ///
    /// <returns>	True if empty, false if not. </returns>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    bool isEmpty () const
    { return (root == 0) ? true : false; }

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	Gets the root. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ///
    /// <exception cref="Underflow">	Thrown when an underflow error condition occurs. </exception>
    ///
    /// <returns>	The root. </returns>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    T & getRoot () const
    { if (root) return root->element; else throw Underflow(); }

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	Makes an empty binary tree. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    void makeEmpty();

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	Output preorder. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ///
    /// <param name="out">	[in,out] The outfile. </param>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    void outputPreorder(ostream &out) const;
    
private:
    /// <summary>	The root. </summary>
    BTNode<T> *root;

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	Makes an empty node. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ///
    /// <param name="r">	[in,out] If non-null, binary tree node pointer to process. </param>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    void makeEmpty (BTNode<T> *r);

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	Copies the subtree described by n. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ///
    /// <param name="n">	The node to process. </param>
    ///
    /// <returns>	Null if it fails, else a pointer to a node; </returns>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    BTNode<T> *copySubtree(const BTNode<T> *n) const;

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	Output preorder. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ///
    /// <param name="out">	[in,out] The outfile. </param>
    /// <param name="n">  	The node pointer to process. </param>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    void outputPreorder(ostream &out, const BTNode<T> *n) const;

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	A bt itr in. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ///
    /// <typeparam name="T">	Generic type parameter. </typeparam>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    friend class BTItrIn<T>;

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	A bt itr pre. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ///
    /// <typeparam name="T">	Generic type parameter. </typeparam>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    friend class BTItrPre<T>;

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	A bt itr post. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ///
    /// <typeparam name="T">	Generic type parameter. </typeparam>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    friend class BTItrPost<T>;

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	A bt itr level. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ///
    /// <typeparam name="T">	Generic type parameter. </typeparam>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    friend class BTItrLevel<T>;
};


template <class T>
BinaryTree<T>::BinaryTree(const T &v)
{
    root = new BTNode<T>(v);
}

template <class T>
BinaryTree<T>::BinaryTree(const BinaryTree<T> &t)
{
    root = copySubtree(t.root);
}

template <class T>
BTNode<T> *BinaryTree<T>::copySubtree(const BTNode<T> *n) const
{
    if (n) {
        BTNode<T> *node = new BTNode<T>(n->element, copySubtree(n->left),
                                        copySubtree(n->right));
        return node;
    } else
        return 0;
}

template <class T>
BinaryTree<T>::BinaryTree(const T&elem, const BinaryTree & esq,
                          const BinaryTree & dir)
{
    root = new BTNode<T>(elem, copySubtree(esq.root), copySubtree(dir.root));
}

template <class T>
const BinaryTree<T> & BinaryTree<T>::operator=(const BinaryTree<T> & rhs)
{
    if (this != & rhs) {
        makeEmpty();
        root = copySubtree(rhs.root);
    }
    return *this;
}


template <class T>
void BinaryTree<T>::makeEmpty()
{
    makeEmpty(root);
}


template <class T>
void BinaryTree<T>::makeEmpty(BTNode<T> *r)
{
    if (r) {
        makeEmpty(r->left);
        makeEmpty(r->right);
        delete r;
    }
}

template <class T>
void BinaryTree<T>::outputPreorder(ostream &out) const
{
    outputPreorder(out, root);
    
}

template <class T>
void BinaryTree<T>::outputPreorder(ostream &out, const BTNode<T> *r) const
{
    out << '(';
    if (r) {
        out <<  r->element << ' ';
        outputPreorder(out, r->left);
        out << ' ';
        outputPreorder(out, r->right);
    }
    out << ')';
}

// Para usar o operador <<

////////////////////////////////////////////////////////////////////////////////////////////////////
/// <summary>	Cast that converts the given ostream into a binary tree; </summary>
///
/// <remarks>	Luís, 20/11/2016. </remarks>
///
/// <param name="out">	[in,out] The outfile. </param>
/// <param name="t">  	The binary tree to process. </param>
///
/// <returns>	The result of the operation. </returns>
////////////////////////////////////////////////////////////////////////////////////////////////////

template <class T>
ostream &operator<<(ostream &out, const BinaryTree<T> &t)
{
    t.outputPreorder(out);
    return out;
}


// Iteradores

template <class T>

////////////////////////////////////////////////////////////////////////////////////////////////////
/// <summary>	A post binary tree iterator. </summary>
///
/// <remarks>	Luís, 20/11/2016. </remarks>
////////////////////////////////////////////////////////////////////////////////////////////////////

class BTItrPost {
public:

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	Constructor. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ///
    /// <param name="bt">	The binary tree. </param>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    BTItrPost(const BinaryTree<T> &bt);

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	Advances this object. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    void advance();

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	Retrieves a reference to a T. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ///
    /// <returns>	A reference to a T. </returns>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    T &retrieve() { return itrStack.top()->element; }

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	Query if this object is at end. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ///
    /// <returns>	True if at end, false if not. </returns>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    bool isAtEnd() {return itrStack.empty(); }
    
private:
    /// <summary>	Stack of itrs. </summary>
    stack<BTNode<T> *> itrStack;
    /// <summary>	Stack of visits. </summary>
    stack<bool> visitStack;

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	Slide down. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ///
    /// <param name="n">	[in,out] If non-null, the binary tree node to process. </param>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    void slideDown(BTNode<T> *n);
};


template <class T>
BTItrPost<T>::BTItrPost (const BinaryTree<T> &bt)
{
    if (!bt.isEmpty())
        slideDown(bt.root);
}

template <class T>
void BTItrPost<T>::advance ()
{
    itrStack.pop();
    visitStack.pop();
    if ((!itrStack.empty()) && (visitStack.top() == false)) {
        visitStack.pop();
        visitStack.push(true);
        slideDown(itrStack.top()->right);
    }
}

template <class T>
void BTItrPost<T>::slideDown(BTNode<T> *n)
{
    while (n) {
        itrStack.push(n);
        if (n->left) {
            visitStack.push(false);
            n = n->left;
        } else if (n->right) {
            visitStack.push(true);
            n = n->right;
        } else {
            visitStack.push(true);
            break;
        }
    }
}


/////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////
/// <summary>	A pre binary tree iterator. </summary>
///
/// <remarks>	Luís, 20/11/2016. </remarks>
///
/// <typeparam name="T">	Generic type parameter. </typeparam>
////////////////////////////////////////////////////////////////////////////////////////////////////

template <class T>
class BTItrPre {
public:

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	Constructor. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ///
    /// <param name="bt">	The bt. </param>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    BTItrPre(const BinaryTree<T> &bt);

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	Advances this object. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    void advance();

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	Retrieves a reference to a T. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ///
    /// <returns>	A reference to a T. </returns>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    T &retrieve() { return itrStack.top()->element; }

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	Query if this object is at end. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ///
    /// <returns>	True if at end, false if not. </returns>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    bool isAtEnd() {return itrStack.empty(); }
    
private:
    /// <summary>	Stack of iterators. </summary>
    stack<BTNode<T> *> itrStack;
    
};

template <class T>
BTItrPre<T>::BTItrPre (const BinaryTree<T> &bt)
{
    if (!bt.isEmpty())
        itrStack.push(bt.root);
}

template <class T>
void BTItrPre<T>::advance()
{
    BTNode<T> * actual = itrStack.top();
    BTNode<T> * seguinte = actual->left;
    if (seguinte)
        itrStack.push(seguinte);
    else {
        while (!itrStack.empty()) {
            actual = itrStack.top();
            itrStack.pop();
            seguinte = actual -> right;
            if (seguinte) {
                itrStack.push(seguinte);
                break;
            }
        }
    }
}


template <class T>

////////////////////////////////////////////////////////////////////////////////////////////////////
/// <summary>	An in binary tree iterator. </summary>
///
/// <remarks>	Luís, 20/11/2016. </remarks>
////////////////////////////////////////////////////////////////////////////////////////////////////

class BTItrIn {
public:

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	Constructor. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ///
    /// <param name="bt">	The binary tree. </param>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    BTItrIn(const BinaryTree<T> &bt);

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	Advances this object. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    void advance();

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	Retrieves a reference to a T. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ///
    /// <returns>	A reference to a T. </returns>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    T &retrieve() { return itrStack.top()->element; }

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	Query if this object is at end. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ///
    /// <returns>	True if at end, false if not. </returns>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    bool isAtEnd() {return itrStack.empty(); }
    
private:
    /// <summary>	Stack of itrs. </summary>
    stack<BTNode<T> *> itrStack;

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	Slide left. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ///
    /// <param name="n">	[in,out] If non-null, the BTNode&lt;T&gt; to process. </param>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    void slideLeft(BTNode<T> *n);
};

template <class T>
BTItrIn<T>::BTItrIn (const BinaryTree<T> &bt)
{
    if (!bt.isEmpty())
        slideLeft(bt.root);
}

template <class T>
void BTItrIn<T>::slideLeft(BTNode<T> *n)
{
    while (n) {
        itrStack.push(n);
        n = n->left;
    }
}

template <class T>
void BTItrIn<T>::advance()
{
    BTNode<T> * actual = itrStack.top();
    itrStack.pop();
    BTNode<T> * seguinte = actual->right;
    if (seguinte)
        slideLeft(seguinte);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// <summary>	A level binary tree iterator. </summary>
///
/// <remarks>	Luís, 20/11/2016. </remarks>
///
/// <typeparam name="T">	Generic type parameter. </typeparam>
////////////////////////////////////////////////////////////////////////////////////////////////////

template <class T>
class BTItrLevel {
public:

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	Constructor. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ///
    /// <param name="bt">	The bt. </param>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    BTItrLevel(const BinaryTree<T> &bt);

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	Advances this object. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    void advance();

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	Retrieves a reference to a T. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ///
    /// <returns>	A reference to a T. </returns>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    T &retrieve() { return itrQueue.front()->element; }

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	Gets the node. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ///
    /// <returns>	Null if it fails, else the node. </returns>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    BTNode<T>* getNode() const {return itrQueue.front();};

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>	Query if this object is at end. </summary>
    ///
    /// <remarks>	Luís, 20/11/2016. </remarks>
    ///
    /// <returns>	True if at end, false if not. </returns>
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    bool isAtEnd() {return itrQueue.empty(); }
    
private:
    /// <summary>	Queue of itrs. </summary>
    queue<BTNode<T> *> itrQueue;
    
};

template <class T>
BTItrLevel<T>::BTItrLevel (const BinaryTree<T> &bt)
{
    if (!bt.isEmpty())
        itrQueue.push(bt.root);
}

template <class T>
void BTItrLevel<T>::advance()
{
    BTNode<T> * actual = itrQueue.front();
    itrQueue.pop();
    BTNode<T> * seguinte = actual->left;
    if (seguinte)
        itrQueue.push(seguinte);
    seguinte = actual->right;
    if (seguinte)
        itrQueue.push(seguinte);
}



#endif
